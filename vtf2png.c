#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include <fcntl.h>
#include <unistd.h>
#include <png.h>
#include <sys/mman.h>

enum
{
      IMAGE_FORMAT_NONE = -1,
      IMAGE_FORMAT_RGBA8888 = 0,
      IMAGE_FORMAT_ABGR8888,
      IMAGE_FORMAT_RGB888,
      IMAGE_FORMAT_BGR888,
      IMAGE_FORMAT_RGB565,
      IMAGE_FORMAT_I8,
      IMAGE_FORMAT_IA88,
      IMAGE_FORMAT_P8,
      IMAGE_FORMAT_A8,
      IMAGE_FORMAT_RGB888_BLUESCREEN,
      IMAGE_FORMAT_BGR888_BLUESCREEN,
      IMAGE_FORMAT_ARGB8888,
      IMAGE_FORMAT_BGRA8888,
      IMAGE_FORMAT_DXT1,
      IMAGE_FORMAT_DXT3,
      IMAGE_FORMAT_DXT5,
      IMAGE_FORMAT_BGRX8888,
      IMAGE_FORMAT_BGR565,
      IMAGE_FORMAT_BGRX5551,
      IMAGE_FORMAT_BGRA4444,
      IMAGE_FORMAT_DXT1_ONEBITALPHA,
      IMAGE_FORMAT_BGRA5551,
      IMAGE_FORMAT_UV88,
      IMAGE_FORMAT_UVWQ8888,
      IMAGE_FORMAT_RGBA16161616F,
      IMAGE_FORMAT_RGBA16161616,
      IMAGE_FORMAT_UVLX8888
};

const char* formatToName(int format)
{
  switch(format) {
    case IMAGE_FORMAT_RGBA8888:
      return "RGBA8888";
    case IMAGE_FORMAT_ABGR8888:
      return "ABGR8888";
    case IMAGE_FORMAT_RGB888:
      return "RGB888";
    case IMAGE_FORMAT_BGR888:
      return "BGR888";
    case IMAGE_FORMAT_RGB565:
      return "RGB565";
    case IMAGE_FORMAT_I8:
      return "I8";
    case IMAGE_FORMAT_IA88:
      return "IA88";
    case IMAGE_FORMAT_P8:
      return "P8";
    case IMAGE_FORMAT_A8:
      return "A8";
    case IMAGE_FORMAT_RGB888_BLUESCREEN:
      return "RGB888_BLUESCREEN";
    case IMAGE_FORMAT_BGR888_BLUESCREEN:
      return "BGR888_BLUESCREEN";
    case IMAGE_FORMAT_ARGB8888:
      return "ARGB8888";
    case IMAGE_FORMAT_BGRA8888:
      return "BGRA8888";
    case IMAGE_FORMAT_DXT1:
      return "DXT1";
    case IMAGE_FORMAT_DXT3:
      return "DXT3";
    case IMAGE_FORMAT_DXT5:
      return "DXT5";
    case IMAGE_FORMAT_BGRX8888:
      return "BGRX8888";
    case IMAGE_FORMAT_BGR565:
      return "BGR565";
    case IMAGE_FORMAT_BGRX5551:
      return "BGRX5551";
    case IMAGE_FORMAT_BGRA4444:
      return "BGRA4444";
    case IMAGE_FORMAT_DXT1_ONEBITALPHA:
      return "DXT1_ONEBITALPHA";
    case IMAGE_FORMAT_BGRA5551:
      return "BGRA5551";
    case IMAGE_FORMAT_UV88:
      return "UV88";
    case IMAGE_FORMAT_UVWQ8888:
      return "UVWQ8888";
    case IMAGE_FORMAT_RGBA16161616F:
      return "RGBA16161616F";
    case IMAGE_FORMAT_RGBA16161616:
      return "RGBA16161616";
    case IMAGE_FORMAT_UVLX8888:
      return "UVLX8888";
  }
  return "unknown";
}

enum
{
      // Flags from the *.txt config file
      TEXTUREFLAGS_POINTSAMPLE = 0x00000001,
      TEXTUREFLAGS_TRILINEAR = 0x00000002,
      TEXTUREFLAGS_CLAMPS = 0x00000004,
      TEXTUREFLAGS_CLAMPT = 0x00000008,
      TEXTUREFLAGS_ANISOTROPIC = 0x00000010,
      TEXTUREFLAGS_HINT_DXT5 = 0x00000020,
      TEXTUREFLAGS_PWL_CORRECTED = 0x00000040,
      TEXTUREFLAGS_NORMAL = 0x00000080,
      TEXTUREFLAGS_NOMIP = 0x00000100,
      TEXTUREFLAGS_NOLOD = 0x00000200,
      TEXTUREFLAGS_ALL_MIPS = 0x00000400,
      TEXTUREFLAGS_PROCEDURAL = 0x00000800,
 
      // These are automatically generated by vtex from the texture data.
      TEXTUREFLAGS_ONEBITALPHA = 0x00001000,
      TEXTUREFLAGS_EIGHTBITALPHA = 0x00002000,
 
      // Newer flags from the *.txt config file
      TEXTUREFLAGS_ENVMAP = 0x00004000,
      TEXTUREFLAGS_RENDERTARGET = 0x00008000,
      TEXTUREFLAGS_DEPTHRENDERTARGET = 0x00010000,
      TEXTUREFLAGS_NODEBUGOVERRIDE = 0x00020000,
      TEXTUREFLAGS_SINGLECOPY      = 0x00040000,
      TEXTUREFLAGS_PRE_SRGB = 0x00080000,
 
        TEXTUREFLAGS_UNUSED_00100000 = 0x00100000,
      TEXTUREFLAGS_UNUSED_00200000 = 0x00200000,
      TEXTUREFLAGS_UNUSED_00400000 = 0x00400000,
 
      TEXTUREFLAGS_NODEPTHBUFFER = 0x00800000,
 
      TEXTUREFLAGS_UNUSED_01000000 = 0x01000000,
 
      TEXTUREFLAGS_CLAMPU = 0x02000000,
      TEXTUREFLAGS_VERTEXTEXTURE = 0x04000000,
      TEXTUREFLAGS_SSBUMP = 0x08000000,                  
 
      TEXTUREFLAGS_UNUSED_10000000 = 0x10000000,
 
      TEXTUREFLAGS_BORDER = 0x20000000,
 
      TEXTUREFLAGS_UNUSED_40000000 = 0x40000000,
      TEXTUREFLAGS_UNUSED_80000000 = 0x80000000,
};

typedef struct 
{
  char           signature[4];       // File signature ("VTF\0"). (or as little-endian integer, 0x00465456)
  unsigned int   version[2];         // version[0].version[1] (currently 7.2).
  unsigned int   headerSize;         // Size of the header struct (16 byte aligned; currently 80 bytes).
  unsigned short width;              // Width of the largest mipmap in pixels. Must be a power of 2.
  unsigned short height;             // Height of the largest mipmap in pixels. Must be a power of 2.
  unsigned int   flags;              // VTF flags.
  unsigned short frames;             // Number of frames, if animated (1 for no animation).
  unsigned short firstFrame;         // First frame in animation (0 based).
  unsigned char  padding0[4];        // reflectivity padding (16 byte alignment).
  float          reflectivity[3];    // reflectivity vector.
  unsigned char  padding1[4];        // reflectivity padding (8 byte packing).
  float          bumpmapScale;       // Bumpmap scale.
  unsigned int   highResImageFormat; // High resolution image format.
  unsigned char  mipmapCount;        // Number of mipmaps.
  unsigned int   lowResImageFormat;  // Low resolution image format (always DXT1).
  unsigned char  lowResImageWidth;   // Low resolution image width.
  unsigned char  lowResImageHeight;  // Low resolution image height.
  unsigned short depth;              // Depth of the largest mipmap in pixels.
                                     // Must be a power of 2. Can be 0 or 1 for a 2D texture (v7.2 only).
} vtfheader;

void rgb565_to_rgb888(uint16_t in, uint8_t *out)
{
  uint8_t r,g,b;
  r = (uint8_t) (in >> 11) & 31;
  r = (r << 3) | (r >> 2);
  g = (uint8_t) (in >>  5) & 63;
  g = (g << 2) | (g >> 4);
  b = (uint8_t) (in >>  0) & 31;
  b = (b << 3) | (b >> 2);
  out[0] = r;
  out[1] = g;
  out[2] = b;
}

//DXT uses 4x4 pixel blocks encoded as 128 bits each

// DXT1
// |08|08|08|08| 32 bits wide
// 
// |-c0--|-c1--|
// |----ci-----|

// DXT3
// |08|08|08|08| 32 bits wide
// 
// |---alpha---|
// |---alpha---|
// |-c0--|-c1--|
// |----ci-----|

// DXT5
// |08|08|08|08| 32 bits wide
// 
// |a0|a1|--ai-|
// |----ai-----|
// |-c0--|-c1--|
// |----ci-----|

void decodeDXT5(uint8_t** rgbaRows, uint8_t* data, int filesize, int frame)
{

  vtfheader* header = (vtfheader*) data;
  char* img = malloc(header->width * header->height * 4);
  int framesize = ((header->width+3)/4) * ((header->height+3)/4) * (128/8);
  int pos = filesize - (framesize*frame);

  uint8_t a[8]; //alpha values
  uint64_t ai; //alpha indices
  uint8_t r[4]; //r for color values
  uint8_t g[4]; //g for color values
  uint8_t b[4]; //b for color values
  uint32_t ci; //color indices

  for(int i = 0; i < header->height; i += 4) {
    for(int j = 0; j < header->width; j += 4) {
      //First calculate our alpha values
      a[0] = data[pos++];
      a[1] = data[pos++];
      if(a[0] > a[1]) {
        for(int k = 0; k < 6; ++k)
          a[2+k] = ((12-(2*k))*a[0] + (2+2*k)*a[1] + 7) / 14;
      } else {
        for(int k = 0; k < 4; ++k)
          a[2+k] = ((8-(2*k))*a[0] + (2+2*k)*a[1] + 5) / 10;
        a[6] = 0; a[7] = 255;
      }

      //Now extract the alpha indices
      ai = 0;
      for(int i = 0; i <= 40; i += 8)
        ai |= (uint64_t)data[pos++] << i;

      //Now extract our two main color values
      uint8_t c888[3];
      uint16_t cp = data[pos++];
      cp |= data[pos++] << 8;

      rgb565_to_rgb888(cp, &c888[0]);
      r[0] = c888[0];
      g[0] = c888[1];
      b[0] = c888[2];

      cp = data[pos++];
      cp |= data[pos++] << 8;
      rgb565_to_rgb888(cp, &c888[0]);
      r[0] = c888[0];
      g[0] = c888[1];
      b[0] = c888[2];

      //and calculate the other two
      r[2] = (4*r[0] + 2*r[1] + 3)/6;
      g[2] = (4*g[0] + 2*g[1] + 3)/6;
      b[2] = (4*b[0] + 2*b[1] + 3)/6;
      r[3] = (2*r[0] + 4*r[1] + 3)/6;
      g[3] = (2*g[0] + 4*g[1] + 3)/6;
      b[3] = (2*b[0] + 4*b[1] + 3)/6;

      //Extract the color indices
      ci = 0;
      for(int i = 0; i <= 24; i += 8)
        ci |= (uint64_t)data[pos++] << i;

      //Now we just index the colours+alpha values to build our block
      for(int y = 0; y < 4; ++y) {
        for(int x = 0; x < 4; ++x) {
          rgbaRows[i+y][4*j+4*x+0] = r[ci & 3];
          rgbaRows[i+y][4*j+4*x+1] = g[ci & 3];
          rgbaRows[i+y][4*j+4*x+2] = b[ci & 3];
          rgbaRows[i+y][4*j+4*x+3] = a[ai & 7];
          //Move to the next color & alpha index
          ci >>= 2; ai >>= 3;
        }
      }
    }
  }
}

int main(int argc, char** argv)
{
  if(argc < 3) {
    printf("Usage: %s [-f frame] <in.vtf> <out.png>\n", argv[0]);
    return 1;
  }

  const char* filepath = argv[argc-2];
  const char* outpath = argv[argc-1];
  int frame = 1;

  for(int a = 1; a < argc - 1; ++a) {
    if(strcmp("-f", argv[a]) == 0)
      frame = atoi(argv[a+1]);
  }

  int fd = open(filepath, O_RDONLY);
  if (fd < 0) {
    printf("Unable to open \"%s\"\n", filepath);
    return 2;
  }

  int filesize = lseek(fd, 0, SEEK_END);
  uint8_t* filedata = mmap(0, filesize, PROT_READ, MAP_PRIVATE, fd, 0);
  vtfheader* header = (vtfheader*)filedata;

  printf(" - VTF HEADER - \n"
      "version: %i.%i\n"
      "width: %i\n"
      "height: %i\n"
      "frames: %i\n"
      "mipmaps: %i\n"
      "format: %s\n",
      header->version[0], header->version[1],
      header->width,
      header->height,
      header->frames,
      header->mipmapCount,
      formatToName(header->highResImageFormat));

  //Array of pointers to each row array
  uint8_t** rgbaRows = malloc(sizeof(uint8_t*)*header->height);
  for(int i = 0; i < header->height; ++i) {
    rgbaRows[i] = malloc(header->width * 4);
    memset(rgbaRows[i], 0xFF, header->width * 4);
  }

  switch(header->highResImageFormat) {
    case IMAGE_FORMAT_DXT5:
      decodeDXT5(rgbaRows, filedata, filesize, frame);
      break;
    default:
      printf("Unsupported format: %s\n", formatToName(header->highResImageFormat));
      return 3;
  }

  //We should now have valid pixel data, so write a png
  FILE* of = fopen(outpath, "wb");
  if(!of) {
    printf("could not open \"%s\" for writing\n", outpath);
    return 4;
  }

  png_structp png_ptr = png_create_write_struct(PNG_LIBPNG_VER_STRING, NULL, NULL, NULL);
  png_infop info_ptr = png_create_info_struct(png_ptr);
  png_init_io(png_ptr, of);

  png_set_IHDR(png_ptr, info_ptr, header->width, header->height, 8,
      PNG_COLOR_TYPE_RGB_ALPHA, PNG_INTERLACE_NONE,
      PNG_COMPRESSION_TYPE_BASE, PNG_FILTER_TYPE_BASE);
  png_write_info(png_ptr, info_ptr);
  png_write_image(png_ptr, rgbaRows);
  png_write_end(png_ptr, NULL);

  fclose(of);

  for(int i = 0; i < header->height; ++i)
    free(rgbaRows[i]);
  free(rgbaRows);
  
  munmap(filedata, filesize);
  close(fd);

  return 0;
}
